---
title: ch2笔记
date: 2024-02-12 17:28:26
category: 
- '训练营笔记'
- '清华大学开源操作系统训练营2023'
tags: 
- 'OS'
- '操作系统'
- 'Rust'
- 'riscv'
---
本文不会将原本`rCore文档`的内容重复太多, 主要是补充学习过程中遇到的知识点, 因此还需结合原文使用, 原文在后面的链接中

之前的章节仅仅是一个裸机运行的应用程序, 这一章节通过特权级的引入实现了S态下的`OS`和U态下的`app`, `app`通过系统调用访问`OS`, `OS`通过`SBI`提供的服务完成系统调用, 不过这一章节没有实现进程或线程切换, 而是将程序一个接一个地运行直到结束。

完整版官方文档： https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/index.html

训练营精简版文档： https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter2/index.html

# 1 整体流程
本章的目的是实现批处理系统，文档中称为`邓氏鱼OS`, 其内容包括:
1. 编写`Rust应用程序`, 并使用链接脚本调整内存布局
2. 为`OS`实现系统调用
3. 将应用程序从`efl`转化为`binary`, 和`OS`的代码链接到一起
4. 实现批处理的任务调度
5. 引入用户栈和内核栈

# 2 特权级
## 2.1 特权级的概念
下面这摘自官方文档张图展示了`riscv`中不同的特权级:

![PrivilegeStack](../../../images/LearningOS/ch2-PrivilegeStack.png)

RISC-V 定义了以下四个特权级别：

1. **用户级别（User-Level or U-Mode）**:
   就是图中的`App`所在的级别, 用户级别是最低的特权级别，普通的应用程序在这个级别上运行。在这个级别上，程序不能直接访问硬件资源，如控制I/O和管理内存等。用户级别的代码需要通过**系统调用**（`syscalls`）与更高特权级别的软件交互来请求服务。而`syscalls`就是应用程序二进制接口, 图中的`ABI`。程序在用户级别也称为用户态

2. **监督者级别（Supervisor-Level or S-Mode）**:
   监督者级别是操作系统内核通常运行的特权级别。它允许直接控制和管理硬件资源，包括内存管理单元（MMU）、中断处理等。大多数操作系统的内核，如`Linux`，会在`S-Mode`下运行。程序在用户级别也称为内核态。操作系统在态下其实也需要想=向更低一级的机器模式提出函数请求，这就是**SBI**所做的事情

3. **机器级别（Machine-Level or M-Mode）**:
   机器级别是最高的特权级别，提供对RISC-V硬件的完全控制。它用于引导系统、处理最底层的中断和异常，以及配置系统的安全和保护设置。固件和监控程序，如我们使用的`RustSBI`（通常在M-Mode下运行。

4. **超级用户级别（Hypervisor-Level or H-Mode）**:
   超级用户级别是为虚拟化环境设计的特权级别，在`RISC-V`体系结构中是一个可选的特权级别。它允许运行一个超级监控器（`hypervisor`），在单个物理硬件平台上虚拟化和管理多个独立的操作系统实例。`rCore`中不涉及这个级别

## 2.2 特权级的切换
官网中的这张图清晰地说明了应用程序如何进行特权级切换:

![EnvironmentCallFlow](../../../images/LearningOS/ch2-EnvironmentCallFlow.png)

这张图其实还揭示了另一个细节: 不同特权级的内存空间通常是不一样的, 这就和我们常说的用户栈和内核栈联系起来了

## 2.3 特权级切换指令和寄存器
### 2.3.1 什么时候会发生特权级切换?
在RISC-V中，特权级切换通常在以下场景中发生：

1. **系统调用（System Calls）**：当用户程序需要操作系统提供的服务时，如文件操作、内存分配等，它会执行一个`ecall`指令来触发一个异常，导致处理器从用户模式（U-Mode）切换到监督者模式（S-Mode）或机器模式（`M-Mode`），这样操作系统可以安全地提供这些服务。

2. **中断（Interrupts）**：当外部设备需要处理器的注意时，它会发送一个中断信号。处理器响应中断信号也会导致特权级切换，通常是从较低的特权级别切换到机器模式（`M-Mode`），以便中断服务程序可以运行并处理中断。

3. **异常（Exceptions）**：当程序执行非法操作（如除以零、访问无权限的内存区域）时，或者出现硬件错误，就会发生异常。这将导致从当前特权级别切换到更高的特权级别，以便异常处理程序可以被执行来处理这些问题。

4. **特权级返回（Return from Trap）**：当中断或异常处理完成后，通过执行`mret`、`sret`或`uret`指令返回到发生中断或异常之前的特权级别。如果异常无法被正常处理, 则可能退出不会返回用户态, 而是在更高的特权级中尽显处理(*关机蓝屏等就是这些更改特权级处理异常的方式*)

通过上述情形可以我们可以看出, 异常控制流(区别与一般的函数控制)和特权级切换有下面的好处:
1. 保护系统和硬件不收错误的程序的损坏
2. 提供一层抽象, 便于开发

### 2.3.2 特权级切换指令和寄存器
1. 特权级切换指令

    | 指令   | 描述 |
    | ------ | ----------- |
    | `ecall`  | 从用户态或监督者态触发一个环境调用异常，请求操作系统服务 |
    | `ebreak` | 触发一个断点异常，用于调试 |
    | `mret`   | 从机器模式退出中断或异常处理程序并返回到之前的特权级别 |
    | `sret`   | 从监督者模式退出中断或异常处理程序并返回到之前的特权级别 |
    | `uret`   | 从用户模式退出中断或异常处理程序并返回到之前的特权级别 |

2. 特权级切换相关寄存器

    | 寄存器   | 描述 |
    | -------- | ------------------------------------------------------- |
    | `mstatus`| 保存机器模式的全局状态，包括全局中断使能位和特权级切换的状态 |
    | `sstatus`| `mstatus` 的子集，用于保存监督者模式的状态信息 |
    | `ustatus`| `mstatus` 的子集，用于保存用户模式的状态信息 |
    | `mtvec`  | 保存中断和异常处理例程的基地址（机器模式） |
    | `stvec`  | 保存监督者模式下中断和异常处理例程的基地址 |
    | `utvec`  | 保存用户模式下中断和异常处理例程的基地址 |
    | `mepc`   | 保存发生异常时的程序计数器值（机器模式） |
    | `sepc`   | 保存监督者模式下发生异常时的程序计数器值 |
    | `uepc`   | 保存用户模式下发生异常时的程序计数器值 |
    | `mcause` | 保存最后一次异常或中断的原因（机器模式） |
    | `scause` | 保存监督者模式下最后一次异常或中断的原因 |
    | `ucause` | 保存用户模式下最后一次异常或中断的原因 |

# 3 系统调用
`riscv`中的系统调用很简单:
1. 把系统调用的参数按照顺序放在`a0~a6`寄存器后
2. 把系统调用号放在`a7`寄存器
3. 调用`ecall`触发系统调用
4. 在`a0`处获得系统调用的返回值

系统调用可以使用`Rust`内联汇编实现:
```rust
use core::arch::asm;
fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```
如果上述汇编代码看不懂, 可以看我的上一篇`rCode`的笔记中关于内联汇编的介绍